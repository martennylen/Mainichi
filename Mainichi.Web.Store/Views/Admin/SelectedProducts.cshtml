@using Mainichi.Web.Store.Extensions
@model IEnumerable<Mainichi.Web.Store.ViewModels.Thing>

<h2>SelectedProducts</h2>
    <ul data-bind="foreach: featuredProducts">
    <li style="display: inline-block; margin-right: 50px; vertical-align: top;">
        <div>
            <img style="max-width: 100px" data-bind="attr: { src: '/Content/Snapshots/Products/' + data().Image }" />
            <p style="text-align: center">
                <a href="#" data-bind="click: editSelectedProduct, visible: !isEditing(), text: data().Name"></a>
                <input style="width: 100px" type="text" data-bind="visible: isEditing, value: data().Id" />
                <div>
                    <button data-bind="visible: isEditing, click: updateSelectedProduct">Ja</button>
                    <button data-bind="visible: isEditing, click: editSelectedProduct">Nej</button>
                </div>
            </p>
        </div>
    </li>
</ul>
<span class="btn btn-success" data-bind="click: saveSelectedProducts">Spara</span>
<span data-bind="visible: actionText().length, text: actionText"></span>

<script>
    var Mainichi = Mainichi || {};
    Mainichi.ViewModels = Mainichi.ViewModels || {};
    Mainichi.ViewModels.Admin = Mainichi.ViewModels.Admin || {};

    Mainichi.ViewModels.Admin.FeaturedProducts = function() {
        var self = this;
        self.actionText = ko.observable('');
        
        self.featuredProducts = ko.computed(function() {
            return _.map(@Html.RenderAsJson(Model), function(p) {
                return new Mainichi.ViewModels.Admin.FeaturedProduct(p, self);
            });
        });
        
        var mapIdentificators = function () {
            return _.map(self.featuredProducts(), function(p) {
                return p.data().Id;
            });
        };
        
        var selectedIdentificators = mapIdentificators();
        self.saveSelectedProducts = function() {
            var possiblyNewIdentificators = mapIdentificators();
            if (!arrayEq(selectedIdentificators, possiblyNewIdentificators)) {
                selectedIdentificators = possiblyNewIdentificators;
                $.post("/Admin/UpdateSelectedProducts", $.param({ FeaturedThingIds: selectedIdentificators }, true)).done(function(reply) {
                    if (reply) {
                        self.actionText(reply.status);
                    }
                });
            } else {
                self.actionText('Listan har inte ändrats.');
            }
        };
    };

    arrayEq = function(a, b) {
        return _.every(_.zip(a, b), function(x) {
            return x[0] === x[1];
        });
    };

    Mainichi.ViewModels.Admin.FeaturedProduct = function(p, pp) {
        var self = this;

        self.data = ko.observable(p);
        
        self.isEditing = ko.observable(false);
        self.editSelectedProduct = function () {
            self.isEditing(!self.isEditing());
        };

        self.updateSelectedProduct = function() {
            $.getJSON('/api/Things/' + self.data().Id.split('/')[1], function(d) {
                if (d !== null) {
                    self.data(d);
                    pp.actionText('');
                } else {
                    pp.actionText('Produkten existerar inte');
                }
            });
            
            self.isEditing(false);
        };
    };

    ko.applyBindings(new Mainichi.ViewModels.Admin.FeaturedProducts());
</script>